/* Extraction of observables from histograms generated by 'PPMdepol_DataReduction' run on the PPMdepol 2009 data set. The extracted observables are stored in a TTree.  */
/* A. T. Holley and D. DeArmitt */
/* Created: June 22, 2016 
 *	Updated: July 1,2016    */

/*
Changelog
---------
[DAD]: Added getholdcounts, getunldcounts, sorted variables, and adjusted HISDIR for my directories.

[DAD]: Made the function (getlogvals) which works but not properly reading lines of the .txt file

[DAD]: Changed %d in fscanf(L:195) to %lf to coincide with doubles declared

[DAD]: Added in needed variables and cleaned up the code some.

[DAD]: Added in the declarations and prototypes for the fit functions.
*/

#include <stdint.h>
#include <TTree.h>
#include <TBranch.h>
#include <TLeaf.h>
#include <TDirectory.h>
#include <TH1F.h>
#include <TH2F.h>
#include <TFile.h>
#include <TGraph.h>
#include <TCanvas.h>
#include <TLegend.h>
#include <TF1.h>
#include <TF2.h>
#include <TROOT.h>

#define HISDIR "./Sum" //Hist. file dir.
#define HISFN "hists_PPMdepol.root" //Histograms file name.
#define EXOFN "obsvbls.root" //Extracted observables file name.

/* Function Prototypes */
//Extraction functions
void getobs(const char*,const char*); //Main function to direct extraction. 
void getiming(int,const char*); //Gets the timing intervals for the requested run.
void getloadcounts(); //Calculates the number of total counts during the loading period.
void getholdcounts(); //Calculates total counts in holding period.
void getunldcounts(); //calculates total counts in unload period.
int getlogvals(); //reads interval times from runlog and draws lines
void getfithold(); //Fits the holding curve and extracts observables
void getfitunld(); //fits unloading curve and extracts observables
void getbgrate(); //gets the background rate for the double exponential fit
void getbsnhold(); //gets background substracted normalized(bsn) hold counts
void getbsnunld(); //gets background substracted normalized(bsn) unload counts

//Lemmings
TTree *setuptree(const char*); //Creates a TTree with name given by argument for storing values.
TH1F* gethist1(const char*); //Loads in a histogram with the supplied name.
TH2F* gethist2(const char*); //Loads in a histogram with the supplied name.
void edivide(double,double,double,double,double*,double*);
void vlinedraw(double,double,int);
void initialize();
/* ------------------- */

//Global ROOT objects.
TDirectory *wrkdir;
TFile *hfp,*tfp;
TTree *tree;

//Timing and other run parameters
int RNUM, rtyp;
double Tload,Thold,Tunload,Tpoison,Tfield;
double loadcounts,eloadcounts;
double holdcounts,eholdcounts;
double unldcounts,eunldcounts;
double Tloadstart, Tloadend,Tholdstart,Tholdend,Tunldstart,Tunldend;
int Tloadstartbin,Tloadendbin,Tholdstartbin,Tholdendbin,Tunldstartbin,Tunldendbin;
double Tbackgroundstart, Tbackgroundend;
int Tbackgroundstartbin,Tbackgroundendbin;
double Sholdfitamp,eSholdfitamp,Lholdfitamp,eLholdfitamp;
//double Sholdfittau,eSholdfittau,Lholdfittau, eLholdfittau;
double Sholdfitbg,eSholdfitbg,Lholdfitbg,eLholdfitbg;
double unldfitamp,eunldfitamp,unldfitbg,eunldfitbg;
double bgrate, ebgrate;
double bsnholdcounts, ebsnholdcounts, bsnunldcounts, ebsnunldcounts;
double tauhat, etauhat, tautwidle, etautwidle; //tautwidle = short, tauhat = long
double tau1, etau1, tau2, etau2;


void getobs(const char* cmnd, const char* drawop) {
  int prun;
  char name[100];
  

  FILE *fp;
  
  int saveflag = 0;
  
  int rnum = atof(cmnd);
  
  wrkdir = gDirectory; //Get a pointer to the current directory.
  
  //Open the histogram file
  sprintf(name,"%s/%s",HISDIR,HISFN);
  hfp = new TFile(name,"READ");
  
  wrkdir->cd(); //Change back to the working directory.
  
  setuptree("tree1"); //Initialize a TTree to hold the extracted values.

  //Extract values from a single run.
  if(rnum > 0) {
    printf("\n ------ Getting observables from run# %d ------\n",rnum);
    initialize();
    /* --- Call analysis functions --- */
    getiming(rnum,"D");
    getloadcounts();
    getholdcounts();
    getunldcounts();
    getbgrate();
    getbsnhold();
    getbsnunld();
    getfithold();
    getfitunld();
    /* ------------------------------- */
  }
  
  if(rnum == 0 && strcmp(cmnd,"file") == 0) {
  	saveflag = 1;
    sprintf(name,"%s/PPMdepolruns.txt",HISDIR);
    fp = fopen(name,"r");
    while(feof(fp) == 0) {
      fscanf(fp,"%d",&prun);
      if(prun > 0) {
        printf("\n ------ Getting observables from run# %d ------\n",prun);
        initialize(); //Initialize all the global analysis variables.
        /* --- Call analysis functions --- */
        getiming(prun,"");
        getloadcounts();
        getholdcounts();
        getunldcounts();
	getbgrate();
	getbsnhold();
	getbsnunld();
        getfithold();
        getfitunld();   
       /* ------------------------------- */
        tree->Fill(); //Fill the values into the tree.
      }
    }
    fclose(fp);
  }
  
  //Save the TTree if we're not drawing and close associated files.
  if(strcmp(drawop,"")==0 && saveflag != 0) {
    sprintf(name,"%s",EXOFN);
    tfp = new TFile(name,"UPDATE"); //Open the extracted observables file.
    wrkdir->cd();
    tree->SetDirectory(tfp); //Move the observables TTree into the file's directory.
    tfp->Write(tree->GetName(),TObject::kOverwrite); //Save the TTree.
    hfp->Close(); //Close the histogram file.
    tfp->Close(); //Close the extracted observables file.
    wrkdir->cd();
  }

  return;
}

/* ---------------- Analysis Functions ---------------- */
void getiming(int rnum, const char *drawop) {
  char name[100];
  
  RNUM = rnum;
  
  if(getlogvals() == -1) return; 
  if(Tpoison != 0) rtyp = 1;
  else rtyp = 0;
  
  
  sprintf(name,"smain%d",RNUM);
  TH1F *main = gethist1(name);
  
  Tloadstart = 0;
  Tloadend = Tloadstart+Tload;
  Tloadstartbin = 0;//main->FindBin(Tloadstart);
  Tloadendbin = main->FindBin(Tloadend);
  
  Tholdstart = Tloadend;
  Tholdend = Tholdstart+Thold;
  Tholdstartbin = main->FindBin(Tholdstart);
  Tholdendbin = main->FindBin(Tholdend);
  
  Tunldstart = Tholdend;
  Tunldend = Tunldstart+Tunload-5;
  Tunldstartbin = main->FindBin(Tunldstart);
  Tunldendbin = main->FindBin(Tunldend);
  
  Tbackgroundstart = Tunldend;
  //Tbackgroundend = main->GetXaxis()->GetMax(); 
  Tbackgroundend = Tbackgroundstart+10.0;
  Tbackgroundstartbin = main->FindBin(Tbackgroundstart);
  Tbackgroundendbin = main->FindBin(Tbackgroundend);
  
  
  
  if(strcmp(drawop,"D")==0) {
    TCanvas *maincan = new TCanvas("Main Detector");
    maincan->cd();
    sprintf(name,"smain%d",rnum);
    main->Draw();
    vlinedraw(Tloadstart,Tloadend,2);
    vlinedraw(Tholdstart,Tholdend,3);
    vlinedraw(Tunldstart,Tunldend,5);
    vlinedraw(Tbackgroundstart,Tbackgroundend,6);
    
  }
  
  //Reporting
  printf("  Getting run# %d timing information...\n",rnum);
  printf("    Tload: %f\n",Tload);
  printf("    Thold: %f\n",Thold);
  printf("    Tunload: %f\n",Tunload);
  printf("    Tfield:   %f\n",Tfield);
  printf("    Tpoison: %f\n\n",Tpoison);
  if(rtyp == 1) printf("Run Type: Poisoning \n");
    else printf("Run Type: Standard \n");
  
  return;
}

int getlogvals() {
 int i;
 int run;
 double load,hold,unld,psn,field;  
 char skip[500];

 FILE *logfp; 
 
 logfp = fopen("Runsheet.txt","r"); // runlog with times
 
 if(logfp == NULL){
  printf("NO RUNLOG!\n");
 return -1; 
 }
 
 run = -1;
 
 for(i=0; i<2; i++) { //skips header
   fgets(skip,500,logfp);
   //printf("%s\n",skip);
 }

 while(feof(logfp)== 0) {
   
   
  fscanf(logfp,"%d %lf %lf %lf %lf %lf", &run, &load, &hold, &unld, &psn, &field);//read in first 5 values on a line in Runsheet.txt 
  if(RNUM == run) break;
  printf("%s\n",fgets(skip,500,logfp));
  
  }  
  if(run == -1) { //If run number wasnt found
    printf("Run not found.\n");                
    fclose(logfp);
    return -1;
  }
  if(run == RNUM) { //sets global variables to values read in from log book  --> NO, GLOBAL VARIABLE WAS ALREADY SET IN FIRST LINE OF GET TIMING. HERE YOU'RE MAKING SURE THAT run and RNUM REALLY ARE THE SAME. = MEANS ASSIGNMENT. == MEANS COMPARISON.
   Tload = load;
   Thold = hold;
   Tunload = unld;
   Tfield = field;
   Tpoison = psn;
   
   fclose(logfp);
   return 0;
  }
  
 fclose(logfp); 
 return -1; 
 }


void getloadcounts() {
  char name[100];
  
  sprintf(name,"smain%d",RNUM);
  TH1F *main = gethist1(name);
  
  loadcounts = main->Integral(Tloadstartbin,Tloadendbin);
  eloadcounts = sqrt(loadcounts);
  
  //Reporting
  printf("  Getting total main detector load counts:\n");
  printf("    total load counts (bins: %d -> %d): %f +/- %f\n\n",Tloadstartbin,Tloadendbin,loadcounts,eloadcounts);
  
  return;
}

void getholdcounts() {
  char name[100];
  
  sprintf(name,"smain%d",RNUM);
  TH1F *main = gethist1(name);
  
  holdcounts = main->Integral(Tholdstartbin,Tholdendbin);
  eholdcounts = sqrt(holdcounts);
  
  //Reporting
  printf("  Getting total main detector hold counts:\n");
  printf("    total hold counts (bins: %d -> %d): %f +/- %f\n\n",Tholdstartbin,Tholdendbin,holdcounts,eholdcounts);
  
 
  return;
}

void getunldcounts() {
  char name[100];
  
  sprintf(name,"smain%d",RNUM);
  TH1F *main = gethist1(name);
  
  unldcounts = main->Integral(Tunldstartbin,Tunldendbin);
  eunldcounts = sqrt(unldcounts);
  
  //Reporting
  printf("  Getting total main detector unload counts:\n");
  printf("    total unload counts (bins: %d -> %d): %f +/- %f\n\n",Tunldstartbin,Tunldendbin,unldcounts,eunldcounts);
  
 
  return;
  
  
}

void getfithold() {
  char name[100];
  int fitmax; 
 
  sprintf(name,"smain%d",RNUM);
  TH1F *main = gethist1(name);
 /*
  sprintf(name,"[0]*exp(-(x-%f)/[1])+[2]",Tloadend);
  TF1 *Sfit = new TF1("fit",name,Tloadend,Tholdend);
  
  Sfit->SetParameter(0,fitmax);
  Sfit->SetParameter(1,2.65);
  Sfit->SetParameter(2,1);
  */
  sprintf(name,"[0]*exp(-(x-%f)/[1])+[2] + [3]*exp(-(x-%f)/[4])+[5]",Tloadend); // short + long
  TF1 *Dfit = new TF1("fit",name,Tloadend,Tholdend);
  
  Dfit->SetParameter(0,fitmax);
  Dfit->SetParameter(1,3);
  Dfit->SetParameter(2,1);
  Dfit->SetParameter(3,1.5);
  Dfit->SetParameter(4,14);
  Dfit->SetParameter(5,1);
 
  fitmax = main->GetBinContent(Tloadendbin);
 
  //main->Fit(Sfit,"LMN","",Tloadend,Tunldstart);
  //Sfit->Draw("same");
  
  main->Fit(Dfit,"LMN","",Tloadend,Tunldstart);
  Dfit->Draw("same");
  
  Sholdfitamp = fit->GetParameter(0);
  eSholdfitamp = fit->GetParError(0);
 
  tautwidle = fit->GetParameter(1);
  etautwidle = fit->GetParError(1);
 
  Sholdfitbg = fit->GetParameter(2);
  eSholdfitbg = fit->GetParError(2);
  
  Lholdfitamp = fit->GetParameter(3);
  eLholdfitamp = fit->GetParError(3);
 
  tauhat = fit->GetParameter(4);
  etauhat = fit->GetParError(4);
 
  Lholdfitbg = fit->GetParameter(5);
  eLholdfitbg = fit->GetParError(5);
 
 //reporting
  printf("Short Hold interval Fit amplitude value for Run %d: %lf +/- %lf\n\n",RNUM,Sholdfitamp,eSholdfitamp);
  printf("Tautwidle value for Run %d: %lf +/- %lf\n\n",RNUM,tautwidle,etautwidle);
  printf("Short Hold interval Fit Background value for Run %d: %lf +/- %lf\n\n",RNUM,Sholdfitbg,eSholdfitbg);
  
  printf("Long Hold interval Fit amplitude value for Run %d: %lf +/- %lf\n\n",RNUM,Lholdfitamp,eLholdfitamp);
  printf("Tauhat value for Run %d: %lf +/- %lf\n\n",RNUM,tauhat,etauhat);
  printf("Long Hold interval Fit Background value for Run %d: %lf +/- %lf\n\n",RNUM,Lholdfitbg,eLholdfitbg);
  
  return;
}

void getfitunld() {
  char name[100]; 
  int fitmax;
  double unldfitstart = Tholdend+1;
 
  sprintf(name,"smain%d",RNUM);
  TH1F *main = gethist1(name);
 
  sprintf(name,"[0]*exp(-(x-%f)/[1])+[2]",unldfitstart);
  TF1 *fit = new TF1("fit",name,Tholdend,Tunldend);
 
  fitmax = main->GetBinContent(unldfitstart);
 
  fit->SetParameter(0,fitmax);
  fit->SetParameter(1,2.5);
  fit->SetParameter(2,1);
  
 
  main->Fit(fit,"LMN","",unldfitstart,Tunldend);
  fit->Draw("same");
  
  unldfitamp = fit->GetParameter(0);
  eunldfitamp = fit->GetParError(0);
 
  tau1 = fit->GetParameter(1);
  etau1 = fit->GetParError(1);
  
  tau2 = tau1;
  etau2 = etau1;
 
  unldfitbg = fit->GetParameter(2);
  eunldfitbg = fit->GetParError(2);
  
  //reporting
  printf("Unload interval Fit amplitude value for Run %d: %lf +/- %lf\n\n",RNUM,unldfitamp,eunldfitamp);
  printf("Tau1 value for Run %d: %lf +/- %lf\n\n",RNUM,tau1,tau2);
  printf("Unload interval Fit Background value for Run %d: %lf +/- %lf\n\n",RNUM,unldfitbg,eunldfitbg);
  
  return; 
}

void getbgrate(){
  char name[100];
  double bg, ebg;
  double bgstart, bgend;
  double bgint;
  
  sprintf(name,"smain%d",RNUM);
  TH1F *main = gethist1(name);
  
  bgstart = main->GetXaxis()->GetBinLowEdge(Tbackgroundstartbin);
  bgend = main->GetXaxis()->GetBinUpEdge(Tbackgroundendbin);
  
  bg = main->Integral(Tbackgroundstartbin, Tbackgroundendbin);
  ebg = sqrt(bg);
  
  bgint = (bgend-bgstart);
  
  bgrate = bg/(bgint);
  ebgrate = ebg/(bgint);
  
  
  printf("\nTime interval for background: %f\n\n", bgint);
  printf("Total Background counts for Run %d: %f\n\n", RNUM, bg);
  printf("Background rate for Run %d: %f +/- %f counts per second\n\n", RNUM, bgrate, ebgrate); 
  
  
  return;
}

void getbsnhold(){
  //char name[100];
  double rateConv, erateConv;
  double bshold, ebshold;
  
  
  //sprintf(name,"smain%d",RNUM);
  //TH1F *main = gethist1(name);
  
  //printf("\n\nbgrate: %f \n\n",bgrate);
  
  rateConv = bgrate * Thold;
  erateConv = ebgrate * Thold;
  bshold = (holdcounts-rateConv);
  
 
  ebshold = sqrt(pow(erateConv, 2) + pow(eholdcounts, 2));
  edivide(bshold, ebshold, loadcounts, eloadcounts, &bsnholdcounts, &ebsnholdcounts);
  
  printf("\nTotal background counts for run %d is %f +/- %f\n\n", RNUM, rateConv, erateConv);
  printf("Total BS Normalized hold counts for run %d is %f +/- %f\n\n",RNUM, bsnholdcounts, ebsnholdcounts);
}

void getbsnunld(){
  //char name[100];
  double rateConv, erateConv;
  double bsunld, ebsunld;
  
  //sprintf(name,"smain%d",RNUM);
  //TH1F *main = gethist1(name);
  
  rateConv = bgrate * Tunload;
  erateConv = ebgrate * Tunload;
  bsunld = (unldcounts-rateConv);
  
  ebsunld = sqrt(pow(erateConv, 2) + pow(eunldcounts, 2));
  edivide(bsunld, ebsunld, loadcounts, eloadcounts, &bsnunldcounts, &ebsnunldcounts);
  
  printf("\nTotal background counts for run %d is %f +/- %f\n\n",RNUM, rateConv, erateConv);
  printf("Total BS Normalized unload counts for run %d is %f +/- %f\n\n",RNUM, bsnunldcounts, ebsnunldcounts);
}

/* ---------------- Lemmings ---------------- */

TH1F* gethist1(const char *name) {
  TH1F *his;
  hfp->cd(); //Change into the directory with the histogram file.
  his = (TH1F*)gDirectory->Get(name);
  if(!his) {
    printf("\n\n Histogram %s not found for run# %d\n",name,RNUM);
    return NULL;
  }
  his->SetDirectory(wrkdir); //Move the new histogram into the working directory.
  wrkdir->cd(); //Change back to the working directory.
  return his;
}


TH2F* gethist2(const char *name) {
  TH2F *his;
  hfp->cd(); //Change into the directory with the histogram file.
  his = (TH2F*)gDirectory->Get(name);
  if(!his) {
    printf("\n\n Histogram %s not found for run# %d\n",name,RNUM);
    return NULL;
  }
  his->SetDirectory(wrkdir); //Move the new histogram into the working directory.
  wrkdir->cd(); //Change back to the working directory.
  return his;
}

int getinterval(TH1F *his, double *startp, double *endp, double scanTstart) {
  int i;
  double start = -1;
  double end = -1;
  int nbins = his->GetXaxis()->GetNbins();

  if(his->GetBinContent(his->FindBin(scanTstart)) == 1) start = scanTstart;
    
  
  for(i=his->FindBin(scanTstart) ; i <= nbins ; i++) {
    if(start != -1 && end != -1) break;
    if(his->GetBinContent(i) == 0 && his->GetBinContent(i+1) == 1)
                                   start = his->GetXaxis()->GetBinUpEdge(i);
    if(his->GetBinContent(i) == 1 && his->GetBinContent(i+1) == 0)
                                   end = his->GetXaxis()->GetBinUpEdge(i);
  }
  
  *startp = start;
  *endp = end;
  
  if(start == -1) {
    //printf("\n  Initial time for run %d was not found!\n\n",RNUM);
    return -1;
  }
  if(end == -1) {
    printf("\n  Final time for run %d was not found!\n\n",RNUM);
    return -1;
  }
  if(start > end) {
    printf("\n  Interval ordering error for run %d!\n\n",RNUM);
    return -1;
  }

  return 0;
}

void edivide(double numr, double enumr, double denom, double edenom, double *result, double *eresult) {

  double penumr = 0;
  if(numr != 0) penumr = enumr/numr;
  double pedenom = 0;
  if(denom != 0) pedenom = edenom/denom;
  double div = numr/denom;
  double pediv = sqrt(pow(penumr,2) + pow(pedenom,2));
  double ediv = pediv * div;
  *result = div;
  *eresult = fabs(ediv);
  
  return;
}




TTree* setuptree(const char* tname) {

  tree = new TTree(tname,"PPMdepol2009 Extracted Data");
  
  //Timing and other run parameters
  tree->Branch("rnum",&RNUM,"rnum/I");
  tree->Branch("rtyp",&rtyp,"rtyp/I");
  tree->Branch("Tload",&Tload,"Tload/D");
  tree->Branch("Thold",&Thold,"Thold/D");
  tree->Branch("Tunload",&Tunload,"Tunload/D");
  tree->Branch("Tpoison",&Tpoison,"Tpoison/D"); 
  tree->Branch("Tfield",&Tfield,"Tfield/D");
  tree->Branch("loadcounts",&loadcounts,"loadcounts/D");
  tree->Branch("eloadcounts",&eloadcounts,"eloadcounts/D");
  tree->Branch("holdcounts",&holdcounts,"holdcounts/D");
  tree->Branch("eholdcounts",&eholdcounts,"eholdcouts/D");
  tree->Branch("unldcounts",&unldcounts,"unldcounts/D");
  tree->Branch("eunldcounts",&eunldcounts,"eunldcounts/D");
  tree->Branch("Tloadstart",&Tloadstart,"Tloadstart/D");
  tree->Branch("Tloadend",&Tloadend,"Tloadend/D");
  tree->Branch("Tholdstart",&Tholdstart,"Tholdstart/D");
  tree->Branch("Tholdend",&Tholdend,"Tholdend/D");
  tree->Branch("Tunldstart",&Tunldstart,"Tunldstart/D");
  tree->Branch("Tunldend",&Tunldend,"Tunldend/D");
  tree->Branch("Tloadstartbin",&Tloadstartbin,"Tloadstartbin/I");
  tree->Branch("Tloadendbin",&Tloadendbin,"Tloadendbin/I");
  tree->Branch("Tholdstartbin",&Tholdstartbin,"Tholdstartbin/I");
  tree->Branch("Tholdendbin",&Tholdendbin,"Tholdendbin/I");
  tree->Branch("Tunldstartbin",&Tunldstartbin,"Tunldstartbin/I");
  tree->Branch("Tunldendbin",&Tunldendbin,"Tunldendbin/I");
  tree->Branch("Tbackgroundstart",&Tbackgroundstart,"Tbackgroundstart/D");
  tree->Branch("Tbackgroundend",&Tbackgroundend,"Tbackgroundend/D");
  tree->Branch("Tbackgroundstartbin",&Tbackgroundstartbin,"Tbackgroundstartbin/I");
  tree->Branch("Tbackgroundendbin",&Tbackgroundendbin,"Tbackgroundendbin/I");
  
  
  
  //long and short amp
  tree->Branch("Sholdfitamp",&Sholdfitamp,"Sholdfitamp/D");
  tree->Branch("eSholdfitamp",&Sholdfitamp,"eSholdfitamp/D");
  tree->Branch("Lholdfitamp",&Lholdfitamp,"Lholdfitamp/D");
  tree->Branch("eLholdfitamp",&Lholdfitamp,"eLholdfitamp/D");
  
  //tautwidle and tahat
  tree->Branch("tautwidle",&tautwidle,"tautwidle/D");
  tree->Branch("etautwidle",&etautwidle,"etautwidle/D");
  tree->Branch("tauhat",&tauhat,"tauhat/D");
  tree->Branch("etauhat",&etauhat,"etauhat/D");

  tree->Branch("Sholdfitbg",&Sholdfitbg,"Sholdfitbg/D");
  tree->Branch("eSholdfitbg",&eSholdfitbg,"eSholdfitbg/D");
  tree->Branch("Lholdfitbg",&Lholdfitbg,"Lholdfitbg/D");
  tree->Branch("eLholdfitbg",&eLholdfitbg,"eLholdfitbg/D");
  
  
  
  tree->Branch("unldfitamp",&unldfitamp,"unldfitamp/D");
  tree->Branch("eunldfitamp",&eunldfitamp,"eunldfitamp/D");
  
  tree->Branch("tau1",&tau1,"tau1/D");
  tree->Branch("etau1",&etau1,"etau1/D");
  tree->Branch("tau2",&tau2,"tau2/D");
  tree->Branch("etau2",&etau2,"etau2/D");
  
  tree->Branch("unldfitbg",&unldfitbg,"unldfitbg/D");
  tree->Branch("eunldfitbg",&eunldfitbg,"eunldfitbg/D");
  
  tree->Branch("bgrate", &bgrate, "bgrate/D");
  tree->Branch("ebgrate", &ebgrate, "ebgrate/D");
  tree->Branch("bsnholdcounts", &bsnholdcounts, "bsnholdcounts/D");
  tree->Branch("ebsnholdcounts", &ebsnholdcounts, "ebsnholdcounts/D");
  tree->Branch("bsnunldcounts", &bsnunldcounts, "bsnunldcounts/D");
  tree->Branch("ebsnunldcounts", &ebsnunldcounts, "ebsnunldcounts/D");
  
  return tree;
}


void initialize() {
    
  RNUM = -999;
  rtyp = -999;

  Tload = -999;    Thold = -999;
  Tunload = -999;  Tpoison = -999;
  
  loadcounts = -999;  eloadcounts = -999;
  holdcounts = -999;  eholdcounts = -999;
  unldcounts = -999;  eunldcounts = -999;
  Tloadstart = -999;  Tloadend = -999;
  Tholdstart = -999;  Tholdend = -999;
  Tunldstart = -999;  Tunldend = -999;
  Tloadstartbin = -999;  Tloadendbin = -999;
  Tholdstartbin = -999;  Tholdendbin = -999;
  Tunldstartbin = -999;  Tunldendbin = -999;
  Tbackgroundstart = -999;  Tbackgroundend = -999;
  Tbackgroundstartbin = -999;  Tbackgroundendbin = -999;
  
  Sholdfitamp = -999;  eSholdfitamp = -999;
  Lholdfitamp = -999;  eLholdfitamp = -999;
  
  tautwidle = -999;  etautwidle = -999;
  tauhat = -999;  etauhat = -999;
  
  Sholdfitbg = -999;  eSholdfitbg = -999;
  Lholdfitbg = -999;  eLholdfitbg = -999;
  
  unldfitamp = -999;  eunldfitamp = -999;
  
  tau1 = -999;  etau1 = -999;
  tau2 = -999;  etau2 = -999;
  
  unldfitbg = -999;  eunldfitbg = -999;
  
  bgrate = -999; ebgrate = -999;
  bsnholdcounts = -999; ebsnholdcounts = -999;
  bsnunldcounts = -999; ebsnunldcounts = -999;
  
                                                  
  return;
}
void vlinedraw(double low, double high,int color) {
  double cutlinelx[2], cutlinehx[2];
  double cutlinely[2], cutlinehy[2];
  cutlinely[0]=0;
  cutlinehy[0]=0;
  cutlinely[1]=1e10;
  cutlinehy[1]=1e10;
  cutlinelx[0] = low;
  cutlinelx[1] = low;
  cutlinehx[0] = high;
  cutlinehx[1] = high;
  TGraph *glow = new TGraph(2,cutlinelx,cutlinely);
  TGraph *ghigh = new TGraph(2,cutlinehx,cutlinehy);
  glow->SetLineColor(color);
  ghigh->SetLineColor(color);
  glow->Draw("same");
  ghigh->Draw("same");
  
  return;
}





















